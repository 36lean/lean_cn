O:12:"CI_DB_result":8:{s:7:"conn_id";N;s:9:"result_id";N;s:12:"result_array";a:2:{i:0;a:6:{s:2:"id";s:3:"455";s:10:"post_title";s:160:"

	 		<img src="http://blog.51cto.com/image/skin/artType03.jpg">


    		    FOSRestBundle功能包：自动路由生成-多REST风格控制器
                ";s:12:"post_content";s:8951:"
    		  <ul class=" list-paddingleft-2">
<li><p>原文出处：<a textvalue="6-automatic-route-generation_multiple-restful-controllers.md" target="_self" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/6-automatic-route-generation_multiple-restful-controllers.md">6-automatic-route-generation_multiple-restful-controllers.md</a></p></li>
<li><p>原文作者：<a target="_self" href="https://github.com/FriendsOfSymfony">FriendsOfSymfony</a></p></li>
<li><p>授权许可：<a href="http://creativecommons.cn/" title="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" rel="nofollow" target="_blank">创作共用协议</a></p></li>
<li><p>翻译人员：FireHare</p></li>
<li><p>校对人员：</p></li>
<li><p>适用版本：FOSRestBundle 0.12.0</p></li>
<li><p>文章状态：草译阶段</p></li>
</ul>
<h1>Relational RESTful controllers routes</h1>
<p>Sometimes it's better to place subresource actions in their own controller, especially when you have more than 2 subresource actions.</p>
<p>有时最好在自己控制器中放置子资源Action，尤其是当您有超过2个以上的子资源Action时。<br></p>
<h2>
<a name="resource-collection" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/6-automatic-route-generation_multiple-restful-controllers.md#resource-collection"></a>Resource collection（资源集）</h2>
<p>In this case, you must first specify resource relations in special rest YML or XML collection:</p>
<p>在本例中，您首先需要在特定的REST风格的YML或XML集中指定资源关系：</p>
<pre class="brush:as3;toolbar:false;"># src/Acme/HelloBundle/Resources/config/users_routes.yml
users:
    type:     rest
    resource: Acme\HelloBundle\Controller\UsersController
comments:
    type:     rest
    parent:   users
    resource: Acme\HelloBundle\Controller\CommentsController</pre>
<p>或</p>
<pre class="brush:as3;toolbar:false;">&lt;!-- src/Acme/HelloBundle/Resources/config/users_routes.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;routes xmlns="http://friendsofsymfony.github.com/schema/rest"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://friendsofsymfony.github.com/schema/rest https://raw.github.com/FriendsOfSymfony/FOSRestBundle/master/Resources/config/schema/routing/rest_routing-1.0.xsd"&gt;
    &lt;import id="users" type="rest" resource="Acme\HelloBundle\Controller\UsersController" /&gt;
    &lt;import type="rest" parent="users" resource="Acme\HelloBundle\Controller\CommentsController" /&gt;
&lt;/routes&gt;</pre>
<p>Notice <code>parent: users</code> option in the second case. This option specifies that the comments resourceis child of the users resource.</p>
<p>注意第二部分的 <code>parent: users</code> 选项。该选项指定了comments资源是user资源的子资源。</p>
<p><br></p>
<p>It is also necessary to add <code>type: rest</code> to the <code>routing.yml</code> file:</p>
<p>在 routing.yml 文件中， <code>type: rest必须要添加：</code></p>
<p></p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
acme_hello:
    type: rest
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<p><br></p>
<p>In this case, your <code>UsersController</code> MUST always have a single resource <code>get...</code> action:</p>
<p>在本例中，您的 <code>UsersController</code> 总是需要有单个资源 get...的Action：</p>
<pre class="brush:php;toolbar:false;">&lt;?php
class UsersController extends Controller
{
    public function getUserAction($slug)
    {} // "get_user"   [GET] /users/{slug}
    ...
}</pre>
<p>It's used to determine the parent collection name. Controller name itself not used in routes auto-generation process and can be any name you like.</p>
<p>它被用来确定父集合名。控制器名自身并不用于路由自动生成处理，它可以是您希望的任何名字。</p>
<h2>Define child resource controller（定义子资源控制器）</h2>
<p></p>
<p><code>CommentsController</code> actions now will looks like:</p>
<p><code>CommentsController</code> Action现在看上去如下所示：</p>
<pre class="brush:php;toolbar:false;">&lt;?php
class CommentsController extends Controller
{
    public function postCommentVoteAction($slug, $id)
    {} // "post_user_comment_vote" [POST] /users/{slug}/comments/{id}/vote
    public function getCommentsAction($slug)
    {} // "get_user_comments"   [GET] /users/{slug}/comments
    public function getCommentAction($slug, $id)
    {} // "get_user_comment"    [GET] /users/{slug}/comments/{id}
    public function deleteCommentAction($slug, $id)
    {} // "delete_user_comment" [DELETE] /users/{slug}/comments/{id}
    public function newCommentsAction($slug)
    {} // "new_user_comments"   [GET] /users/{slug}/comments/new
    public function editCommentAction($slug, $id)
    {} // "edit_user_comment"   [GET] /users/{slug}/comments/{id}/edit
    public function removeCommentAction($slug, $id)
    {} // "remove_user_comment" [GET] /users/{slug}/comments/{id}/remove
}</pre>
<p>Notice, we got rid of the <code>User</code> part in action names. That is because the RestBundle routing already knows, that <code>CommentsController::...</code> is child resources of <code>UsersController::getUser()</code>resource.</p>
<p>注意，我们摆脱了Action名中的User部分。这是因为RestBundle路由已经知道，<code>CommentsController::...</code>是 <code>UsersController::getUser()</code>资源的子资源。</p>
<h2>Include resource collections in application routing（在应用程序路由中包含资源集）</h2>
<p>Last step is mapping of your collection routes into the application <code>routing.yml</code>:</p>
<p>最后一步是将您的集合路由映射到应用程序的 routing.yml 文件中：</p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
users:
    type:     rest
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<p>That's all. Note that it's important to use the <code>type: rest</code> param when including your application'srouting file. Without it, rest routes will still work but resource collections will fail. If you get an exception that contains ...routing loader does not support given key: "parent"... then you are most likely missingthe <code>type: rest</code> param in your application level routes include.</p>
<p>一切搞定。注意当包含您应用程序的路由文件时，<code>type: rest</code>参数是很重要的，如果没有它，REST路由仍会工作，但资源集将失败。如果您得到一个...routing loader does not support given key: "parent"... 的异常的话，那么您最有可能在您应用程序级的路由中没有包含<code>type: rest</code>参数。</p>
<h2>Routes naming（路由命名）</h2>
<p>RestBundle uses REST paths to generate route name. This means, that URL:</p>
<p>RestBundle功能包使用REST风格的路径来生成路由名，这就意味着，URL：</p>
<pre class="brush:as3;toolbar:false;">[POST] /users/{slug}/comments/{id}/vote</pre>
<p>will become the route with the name <code>post_user_comment_vote</code>.</p>
<p>将变成名为<code>post_user_comment_vote</code>的路由。</p>
<p><br></p>
<p>For further examples, see comments of controllers in the code above.</p>
<p>进一步示例，请参见上面代码中控制器的注释。</p>
<h3>Naming collisions（命名冲突）</h3>
<p>Sometimes, routes auto-naming will lead to route names collisions, so RestBundle routecollections provides a <code>name_prefix</code> (<code>name-prefix</code> for xml and <code>@NamePrefix</code> for annotations) parameter (you can use <code>name_prefix</code> only in a file loaded by the rest loader.):</p>
<p>有时，路由自动命名会导致路由名冲突，因此RestBundle路由集提供一个name_prefix参数（xml中是name-prefix、注释则是@NamePrefix），您也可以在被REST加载器加载的文件中只使用name_prefix。</p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
users:
    type: rest  # Required for `RestYamlLoader` to process imported routes
    prefix: /api
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<div class="highlight">
<p><span class="c1"><br></span></p>
<p><span class="c1"></span></p>
<pre class="brush:as3;toolbar:false;"># src/Acme/HelloBundle/Resources/config/users_routes.yml
comments:
    type:         rest
    resource:     "@AcmeHelloBundle\Controller\CommentsController"
    name_prefix:  api_ # Our precious parameter</pre>
<p><span class="c1"></span><br></p>
</div>
<p>With this configuration, route name would become:</p>
<p>根据这个配置，路由名将变为：</p>
<pre class="brush:as3;toolbar:false;">api_vote_user_comment
</pre>
<p>Say NO to name collisions!</p>
<p>对名称冲突说不！<br></p>
    		";s:8:"category";s:1:"6";s:6:"banner";s:69:"http://127.0.0.1/lean/admincp/uploads/photos/20131023032629390897.jpg";s:8:"seo_text";s:0:"";}i:1;a:6:{s:2:"id";s:3:"456";s:10:"post_title";s:125:"

	 		<img src="http://blog.51cto.com/image/skin/artType03.jpg">


    		    FOSRestBundle功能包：概述
                ";s:12:"post_content";s:4320:"
    		  <ul class=" list-paddingleft-2">
<li><p>原文出处：<a target="_self" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md">README.md</a></p></li>
<li><p>原文作者：<a target="_self" href="https://github.com/FriendsOfSymfony">FriendsOfSymfony</a></p></li>
<li><p>授权许可：<a href="http://creativecommons.cn/" title="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" rel="nofollow" target="_blank">创作共用协议</a></p></li>
<li><p>翻译人员：FireHare</p></li>
<li><p>校对人员：</p></li>
<li><p>适用版本：FOSRestBundle 0.12.0</p></li>
<li><p>文章状态：草译阶段</p></li>
</ul>
<p><br></p>
<h1>FOSRestBundle</h1>
<p>This bundle provides various tools to rapidly develop RESTful API's &amp; applications with Symfony2. Features include:</p>
<p>本功能包提供多种工具来快速开发 Symfony2 的 REST 风格 API 和应用，其功能包括：<br></p>
<ul class=" list-paddingleft-2">
<li><p>A View layer to enable output and format agnostic Controllers</p></li>
<li><p>一个视图层，从而使输出和格式与控制器无关<br></p></li>
<li><p>A custom route loader to generate url's following REST conventions</p></li>
<li><p>一个可定制的路由引导器，用以生成遵循REST惯例的URL<br></p></li>
<li><p>Accept header format negotiation including handling for custom mime types</p></li>
<li><p>接收头格式协商，包括处理自定义的MIME类型<br></p></li>
<li><p>RESTful decoding of HTTP request body and Accept headers</p></li>
<li><p>用于HTTP请求包和接收头的REST风格解码<br></p></li>
<li><p>Exception controller for sending appropriate HTTP status codes</p></li>
<li><p>异常控制器，用以发送相应的HTTP状态码<a href="https://packagist.org/packages/FriendsOfSymfony/rest-bundle"></a></p></li>
</ul>
<h2>
<a name="state" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#state"></a>State（状态）</h2>
<p>While the provided feature set is certainly production ready, this Bundle is still under development.As a result users must expect BC breaks when using the master version. Such breaks will however benoted in the <a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/UPGRADING.md">UPGRADING.md</a>.A new version of the Bundle will be tagged in most cases before a BC break, however do not expect bugfixes for these tagged versions.</p>
<p>虽然提供的所有特性肯定是为生产环境准备的，但本功能包仍然处于开发阶段。因此用户在使用主版本时需要期望 BC break。然而这样的break将在UPGRADING.md文件中被提及。在大多数情况下本功能包的新版本将在BC break前被标识，但不要指望在这些标识版本的Bug修复。<br></p>
<h2>
<a name="documentation" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#documentation"></a>Documentation（文档）</h2>
<p>The bulk of the documentation is stored in the <code>Resources/doc/index.md</code>file in this bundle:</p>
<p>大量文档被存放在本功能包的 Resources/doc/index.md文件中。<br></p>
<p><a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">Read the Documentation for master</a></p>
<p><a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">阅读主版本文档<br></a></p>
<h2>
<a name="installation" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#installation"></a>Installation（安装）</h2>
<p>All the installation instructions are located in the <a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">documentation</a>.</p>
<p>所有安装说明都在<a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">此文档</a>中。</p>
<h2>
<a name="license" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#license"></a>License（许可）</h2>
<p>This bundle is under the MIT license. See the complete license in the bundle:</p>
<p>本功能包基于MIT许可。完整许可请参见本功能的：<br></p>
<pre class="brush:bash;toolbar:false;">Resource/meta/LICENSE</pre>
    		";s:8:"category";s:1:"6";s:6:"banner";s:69:"http://127.0.0.1/lean/admincp/uploads/photos/20131024074254554869.jpg";s:8:"seo_text";s:0:"";}}s:13:"result_object";a:2:{i:0;O:8:"stdClass":6:{s:2:"id";s:3:"455";s:10:"post_title";s:160:"

	 		<img src="http://blog.51cto.com/image/skin/artType03.jpg">


    		    FOSRestBundle功能包：自动路由生成-多REST风格控制器
                ";s:12:"post_content";s:8951:"
    		  <ul class=" list-paddingleft-2">
<li><p>原文出处：<a textvalue="6-automatic-route-generation_multiple-restful-controllers.md" target="_self" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/6-automatic-route-generation_multiple-restful-controllers.md">6-automatic-route-generation_multiple-restful-controllers.md</a></p></li>
<li><p>原文作者：<a target="_self" href="https://github.com/FriendsOfSymfony">FriendsOfSymfony</a></p></li>
<li><p>授权许可：<a href="http://creativecommons.cn/" title="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" rel="nofollow" target="_blank">创作共用协议</a></p></li>
<li><p>翻译人员：FireHare</p></li>
<li><p>校对人员：</p></li>
<li><p>适用版本：FOSRestBundle 0.12.0</p></li>
<li><p>文章状态：草译阶段</p></li>
</ul>
<h1>Relational RESTful controllers routes</h1>
<p>Sometimes it's better to place subresource actions in their own controller, especially when you have more than 2 subresource actions.</p>
<p>有时最好在自己控制器中放置子资源Action，尤其是当您有超过2个以上的子资源Action时。<br></p>
<h2>
<a name="resource-collection" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/6-automatic-route-generation_multiple-restful-controllers.md#resource-collection"></a>Resource collection（资源集）</h2>
<p>In this case, you must first specify resource relations in special rest YML or XML collection:</p>
<p>在本例中，您首先需要在特定的REST风格的YML或XML集中指定资源关系：</p>
<pre class="brush:as3;toolbar:false;"># src/Acme/HelloBundle/Resources/config/users_routes.yml
users:
    type:     rest
    resource: Acme\HelloBundle\Controller\UsersController
comments:
    type:     rest
    parent:   users
    resource: Acme\HelloBundle\Controller\CommentsController</pre>
<p>或</p>
<pre class="brush:as3;toolbar:false;">&lt;!-- src/Acme/HelloBundle/Resources/config/users_routes.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;routes xmlns="http://friendsofsymfony.github.com/schema/rest"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://friendsofsymfony.github.com/schema/rest https://raw.github.com/FriendsOfSymfony/FOSRestBundle/master/Resources/config/schema/routing/rest_routing-1.0.xsd"&gt;
    &lt;import id="users" type="rest" resource="Acme\HelloBundle\Controller\UsersController" /&gt;
    &lt;import type="rest" parent="users" resource="Acme\HelloBundle\Controller\CommentsController" /&gt;
&lt;/routes&gt;</pre>
<p>Notice <code>parent: users</code> option in the second case. This option specifies that the comments resourceis child of the users resource.</p>
<p>注意第二部分的 <code>parent: users</code> 选项。该选项指定了comments资源是user资源的子资源。</p>
<p><br></p>
<p>It is also necessary to add <code>type: rest</code> to the <code>routing.yml</code> file:</p>
<p>在 routing.yml 文件中， <code>type: rest必须要添加：</code></p>
<p></p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
acme_hello:
    type: rest
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<p><br></p>
<p>In this case, your <code>UsersController</code> MUST always have a single resource <code>get...</code> action:</p>
<p>在本例中，您的 <code>UsersController</code> 总是需要有单个资源 get...的Action：</p>
<pre class="brush:php;toolbar:false;">&lt;?php
class UsersController extends Controller
{
    public function getUserAction($slug)
    {} // "get_user"   [GET] /users/{slug}
    ...
}</pre>
<p>It's used to determine the parent collection name. Controller name itself not used in routes auto-generation process and can be any name you like.</p>
<p>它被用来确定父集合名。控制器名自身并不用于路由自动生成处理，它可以是您希望的任何名字。</p>
<h2>Define child resource controller（定义子资源控制器）</h2>
<p></p>
<p><code>CommentsController</code> actions now will looks like:</p>
<p><code>CommentsController</code> Action现在看上去如下所示：</p>
<pre class="brush:php;toolbar:false;">&lt;?php
class CommentsController extends Controller
{
    public function postCommentVoteAction($slug, $id)
    {} // "post_user_comment_vote" [POST] /users/{slug}/comments/{id}/vote
    public function getCommentsAction($slug)
    {} // "get_user_comments"   [GET] /users/{slug}/comments
    public function getCommentAction($slug, $id)
    {} // "get_user_comment"    [GET] /users/{slug}/comments/{id}
    public function deleteCommentAction($slug, $id)
    {} // "delete_user_comment" [DELETE] /users/{slug}/comments/{id}
    public function newCommentsAction($slug)
    {} // "new_user_comments"   [GET] /users/{slug}/comments/new
    public function editCommentAction($slug, $id)
    {} // "edit_user_comment"   [GET] /users/{slug}/comments/{id}/edit
    public function removeCommentAction($slug, $id)
    {} // "remove_user_comment" [GET] /users/{slug}/comments/{id}/remove
}</pre>
<p>Notice, we got rid of the <code>User</code> part in action names. That is because the RestBundle routing already knows, that <code>CommentsController::...</code> is child resources of <code>UsersController::getUser()</code>resource.</p>
<p>注意，我们摆脱了Action名中的User部分。这是因为RestBundle路由已经知道，<code>CommentsController::...</code>是 <code>UsersController::getUser()</code>资源的子资源。</p>
<h2>Include resource collections in application routing（在应用程序路由中包含资源集）</h2>
<p>Last step is mapping of your collection routes into the application <code>routing.yml</code>:</p>
<p>最后一步是将您的集合路由映射到应用程序的 routing.yml 文件中：</p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
users:
    type:     rest
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<p>That's all. Note that it's important to use the <code>type: rest</code> param when including your application'srouting file. Without it, rest routes will still work but resource collections will fail. If you get an exception that contains ...routing loader does not support given key: "parent"... then you are most likely missingthe <code>type: rest</code> param in your application level routes include.</p>
<p>一切搞定。注意当包含您应用程序的路由文件时，<code>type: rest</code>参数是很重要的，如果没有它，REST路由仍会工作，但资源集将失败。如果您得到一个...routing loader does not support given key: "parent"... 的异常的话，那么您最有可能在您应用程序级的路由中没有包含<code>type: rest</code>参数。</p>
<h2>Routes naming（路由命名）</h2>
<p>RestBundle uses REST paths to generate route name. This means, that URL:</p>
<p>RestBundle功能包使用REST风格的路径来生成路由名，这就意味着，URL：</p>
<pre class="brush:as3;toolbar:false;">[POST] /users/{slug}/comments/{id}/vote</pre>
<p>will become the route with the name <code>post_user_comment_vote</code>.</p>
<p>将变成名为<code>post_user_comment_vote</code>的路由。</p>
<p><br></p>
<p>For further examples, see comments of controllers in the code above.</p>
<p>进一步示例，请参见上面代码中控制器的注释。</p>
<h3>Naming collisions（命名冲突）</h3>
<p>Sometimes, routes auto-naming will lead to route names collisions, so RestBundle routecollections provides a <code>name_prefix</code> (<code>name-prefix</code> for xml and <code>@NamePrefix</code> for annotations) parameter (you can use <code>name_prefix</code> only in a file loaded by the rest loader.):</p>
<p>有时，路由自动命名会导致路由名冲突，因此RestBundle路由集提供一个name_prefix参数（xml中是name-prefix、注释则是@NamePrefix），您也可以在被REST加载器加载的文件中只使用name_prefix。</p>
<pre class="brush:as3;toolbar:false;"># app/config/routing.yml
users:
    type: rest  # Required for `RestYamlLoader` to process imported routes
    prefix: /api
    resource: "@AcmeHelloBundle/Resources/config/users_routes.yml"</pre>
<div class="highlight">
<p><span class="c1"><br></span></p>
<p><span class="c1"></span></p>
<pre class="brush:as3;toolbar:false;"># src/Acme/HelloBundle/Resources/config/users_routes.yml
comments:
    type:         rest
    resource:     "@AcmeHelloBundle\Controller\CommentsController"
    name_prefix:  api_ # Our precious parameter</pre>
<p><span class="c1"></span><br></p>
</div>
<p>With this configuration, route name would become:</p>
<p>根据这个配置，路由名将变为：</p>
<pre class="brush:as3;toolbar:false;">api_vote_user_comment
</pre>
<p>Say NO to name collisions!</p>
<p>对名称冲突说不！<br></p>
    		";s:8:"category";s:1:"6";s:6:"banner";s:69:"http://127.0.0.1/lean/admincp/uploads/photos/20131023032629390897.jpg";s:8:"seo_text";s:0:"";}i:1;O:8:"stdClass":6:{s:2:"id";s:3:"456";s:10:"post_title";s:125:"

	 		<img src="http://blog.51cto.com/image/skin/artType03.jpg">


    		    FOSRestBundle功能包：概述
                ";s:12:"post_content";s:4320:"
    		  <ul class=" list-paddingleft-2">
<li><p>原文出处：<a target="_self" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md">README.md</a></p></li>
<li><p>原文作者：<a target="_self" href="https://github.com/FriendsOfSymfony">FriendsOfSymfony</a></p></li>
<li><p>授权许可：<a href="http://creativecommons.cn/" title="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" rel="nofollow" target="_blank">创作共用协议</a></p></li>
<li><p>翻译人员：FireHare</p></li>
<li><p>校对人员：</p></li>
<li><p>适用版本：FOSRestBundle 0.12.0</p></li>
<li><p>文章状态：草译阶段</p></li>
</ul>
<p><br></p>
<h1>FOSRestBundle</h1>
<p>This bundle provides various tools to rapidly develop RESTful API's &amp; applications with Symfony2. Features include:</p>
<p>本功能包提供多种工具来快速开发 Symfony2 的 REST 风格 API 和应用，其功能包括：<br></p>
<ul class=" list-paddingleft-2">
<li><p>A View layer to enable output and format agnostic Controllers</p></li>
<li><p>一个视图层，从而使输出和格式与控制器无关<br></p></li>
<li><p>A custom route loader to generate url's following REST conventions</p></li>
<li><p>一个可定制的路由引导器，用以生成遵循REST惯例的URL<br></p></li>
<li><p>Accept header format negotiation including handling for custom mime types</p></li>
<li><p>接收头格式协商，包括处理自定义的MIME类型<br></p></li>
<li><p>RESTful decoding of HTTP request body and Accept headers</p></li>
<li><p>用于HTTP请求包和接收头的REST风格解码<br></p></li>
<li><p>Exception controller for sending appropriate HTTP status codes</p></li>
<li><p>异常控制器，用以发送相应的HTTP状态码<a href="https://packagist.org/packages/FriendsOfSymfony/rest-bundle"></a></p></li>
</ul>
<h2>
<a name="state" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#state"></a>State（状态）</h2>
<p>While the provided feature set is certainly production ready, this Bundle is still under development.As a result users must expect BC breaks when using the master version. Such breaks will however benoted in the <a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/UPGRADING.md">UPGRADING.md</a>.A new version of the Bundle will be tagged in most cases before a BC break, however do not expect bugfixes for these tagged versions.</p>
<p>虽然提供的所有特性肯定是为生产环境准备的，但本功能包仍然处于开发阶段。因此用户在使用主版本时需要期望 BC break。然而这样的break将在UPGRADING.md文件中被提及。在大多数情况下本功能包的新版本将在BC break前被标识，但不要指望在这些标识版本的Bug修复。<br></p>
<h2>
<a name="documentation" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#documentation"></a>Documentation（文档）</h2>
<p>The bulk of the documentation is stored in the <code>Resources/doc/index.md</code>file in this bundle:</p>
<p>大量文档被存放在本功能包的 Resources/doc/index.md文件中。<br></p>
<p><a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">Read the Documentation for master</a></p>
<p><a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">阅读主版本文档<br></a></p>
<h2>
<a name="installation" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#installation"></a>Installation（安装）</h2>
<p>All the installation instructions are located in the <a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">documentation</a>.</p>
<p>所有安装说明都在<a href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/index.md">此文档</a>中。</p>
<h2>
<a name="license" class="anchor" href="https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/README.md#license"></a>License（许可）</h2>
<p>This bundle is under the MIT license. See the complete license in the bundle:</p>
<p>本功能包基于MIT许可。完整许可请参见本功能的：<br></p>
<pre class="brush:bash;toolbar:false;">Resource/meta/LICENSE</pre>
    		";s:8:"category";s:1:"6";s:6:"banner";s:69:"http://127.0.0.1/lean/admincp/uploads/photos/20131024074254554869.jpg";s:8:"seo_text";s:0:"";}}s:20:"custom_result_object";a:0:{}s:11:"current_row";i:0;s:8:"num_rows";i:2;s:8:"row_data";N;}